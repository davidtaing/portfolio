---
layout: ../../layouts/BlogLayout.astro
title: "What's the Future Game?"
topic: Tactical vs. Strategic Programming
pubDate: 2023-08-14
description: "I‚Äôve been thinking a lot of about what I call the ‚Äúfuture game‚Äù. Or as John Ousterhout outlines in his book ‚ÄúA Philosophy of Software Design‚Äù, it‚Äôs the idea of Tactical Programming vs Strategic Programming."
author: "David Taing"
image:
  url: "https://images.unsplash.com/photo-1495539406979-bf61750d38ad?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2070&q=80"
  alt: "Screenshot of Exhaustive Switch Statement Code Snippet"
tags: ["typescript", "union", "exhaustive-switch", "switch"]
---

A few months ago, I started thinking a lot about Tactical Programming vs Strategic Programming. I ignored the "future game" and yeah, I learnt the hard way.

Built a feature with assumptions baked in. New requirements came in a few weeks later. And now my assumptions were no longer valid.

That lost me half a day.

### TL;DR:

**Tactical Programming**<br/>
Prioritizing Short Term outcomes. Emphasis on getting things done quickly.

**Strategic Programming**<br/>
Prioritizing Long Term outcomes. Things like robustness, scalability, each of change and more.

---

## You can't be too short-sighted.

### Ever since then, I'll ask the following questions:

> What assumptions I am making?

> What can change in the near future?

> Which of my assumptions will break?

#### üí¨ Company B was recently acquired, we can reasonably expect their APIs to be rebuilt.

Yes, it's something that can break my current assumptions.

Let's explore this one a bit later.

### Other answers:

#### üí¨ [For] - Will we extend this feature in the future? How?

#### üí¨ [Against] - Will we be throwing this away and rebuilding this?

<br />

---

## You can't be too far-sighted either.

Like, don't solve for 100,000 queries per second, if you don't have 100,000 QPS.

Sounds pretty obvious, right? Riiiiiight?

That's an **exaggerated heaps later problem** than it is a **now problem**. Also good chance that we'd probably never see that problem happen. In any case, I hope it's an easy "hell no", or a very Australian "yeeeeeeeeah, nah".

Working on problems we don't have means that we're not working on problems that we do have. As they say in business, time is money.

### The questions I'm asking here are:

> Is this a now problem? Or is this a later problem?

> How much does this actually matter? Can we push this back as a later problem?

> Can we find a way to go around this problem instead of tackling it head on? Are there ways to eliminate this problem?

Note: Comparing this **distant future later problem** to a **low probability now problem** like a distributed system failure mode would also be a super interesting topic. But I'll have to leave that for another day. üòä

---

## The answer probably lies somewhere in the middle.

The way I see it. Is that it's like buying an option contract.

Stealing the definition from [Wikipedia](<https://en.wikipedia.org/wiki/Option_(finance)>).

> In finance, an option is a contract which conveys to its owner, the holder, the right, but not the obligation, to buy or sell a specific quantity of an underlying asset or instrument at a specified strike price on or before a specified date.

In order words, it's a contract where we have the option to execute a transaction, on or before a specified date, generally in the future.

### What about modular monolith architectures? Why are they generally well regarded?

> "There are no right or wrong answers in architecture ‚Äî only trade-offs." - Neal Ford

TODO - Idea generation

- Monoliths vs Microservices is a topic in of itself.

  TL;DR: It really boils down to the idea of "one vs. many". There are pros and cons to both options. It's especially important to acknowledge that there are big cons to going distributed.

- The best architecture for the project will change over time. It buys us the option to more easily evolve into a mircoservices architecture in the future. If you do it right, natural seams will be obvious and it's much easier to define the cut lines.

---

I think mixing and matching the Tactical with the Strategic is the way to go. For me, Tactical Programming is great for making progress given lots of uncertainty, especially when the problem or the task doesn't fit inside your head. Cutting corners and solving for a simplier problem is a prefectly valid way to solve problems.

But I do also realise that the "future game" matters, a lot. There is a cost to cutting corners.

---

## ‚ùì What can or will change in the near future? Will my assumptions hold?

#### üí¨ Company B was recently acquired, we can reasonably expect their APIs to be rebuilt.

Yes, it's something that can break my current assumptions.

Let's explore this one a bit later.

### Other answers:

#### üí¨ [For] - Will we extend this feature in the future? How?

#### üí¨ [Against] - Will we be throwing this away and rebuilding this?

<br />

## Strategic Programming

I think of strategic programming as buying Option contracts.

In finance, these are contracts that allow you

But you can take strategic programming too far. It's worthwhile to justify reasons for why.

---

## ‚ùì Can I justify paying for these options?

#### üí¨ Since the Company B's API was built on top of Company A's API, we will target A's data model instead of B's.

Version 2 of Company B's API probably won't release in a few months, maybe a couple of years. And even longer for B's current API to be retired.

This better positions us to migrate to B's new API when it comes out. I think it's fair to say that B's new API will somewhat be coupled to A's API.

I probably wouldn't care about the API being retired.

But what if Company B adds a new feature?

This could be a good reason for us to migrate in the future. That new feature is probably not going to be in the old API.

### Other answers:

#### üí¨ [For] - We're targeting a modular monolithic architecture, so we can reap the rewards of a modular codebase without paying the distributed systems tax.

Architectures evolve over time and microservices may make more sense in the future.

One of the benefits of having well defined modules is that the cut lines should be more obvious. This should make it easier for us to migrate to a microservices architecture compared to something else, like a big ball of mud monolith.

#### üí¨ [Terrible] - We're solving for 100K queries per second. But we're are currently handling 100 QPS.

---

This is just a blog post. There's much more that I haven't covered or even thought about.

(Well, I guess, have a quote. üôÇ)

"There are no right or wrong answers in architecture ‚Äî only trade-offs." - Neal Ford
